#                Задание 1
# Функция NOD(x, y) вычисляет наибольший общий делитель двух натуральных чисел x и y


def NOD(x, y):
    while x != 0 and y != 0:
        if x > y:       # если число х больше, чем y, то
            x = x % y   # х присваиваем остаток от деления х на y
        elif x < y:     # и, наоборот, если число y больше, чем x, то
            y = y % x   # y присваиваем остаток от деления y на x
        elif x == y:    # если вдруг числа равны, то НОД равен этим числам
            return x
    return x + y


print('Чтобы найти наибольший общий делитель - НОД. \n'
      'Введите два натуральных числа.\n'
      '***Чтобы закончить введите числа 0, 0')
# Основной блок программы нахождения НОД
while True:
    a = int(input('Первое число '))
    b = int(input('Второе число '))
    if a == b == 0:
        break
    elif NOD(a, b) == 1:
        print('Числа взаимно простые')
        print('НОД(' + str(a) + ',' + str(b) + ')=', NOD(a, b))
    else:
        print('НОД('+str(a)+','+str(b)+')=', NOD(a, b))


#                Задание 2
#  binary_search(array, x) - это функция бинарного поиска в массиве чисел, отсортированного по возрастанию
# array - список (массив) чисел,  x - число, которое нужно найти в массиве.
def binary_search(array, x):
    middle = len(array) // 2  # индекс среднего элемента в списке array
    n = 0                     # индекс начального элемента в списке array, далле n будет зависеть от среднего элемента
    k = len(array) - 1        # индекс конечного элемента в списке, далле k будет зависеть от среднего элемента
    while True:
        if array[middle] == x:   # если средний элемент равен х, то число в списке array
            return print('Число {} в массиве, его индекс равен {}'.format(x, middle))
        elif array[middle] > x:  # если средний элемент больше искомого числа х, то поиск в левой половине списка
            k = middle - 1       # и индекс конечного элемента становится равен индексу среднего элемента минус 1
        elif array[middle] < x:  # если средний элемент меньше искомого числа х, то поиск в правой половине списка
            n = middle + 1       # и индекс начальнного элемента становится равен индексу среднего элемента плюс 1
        if n == (k + 1):         # если индекс начального елемента становится больше индекса конечного,
            return print('Число {} нет в массиве'.format(x))  # то число не в списке array
        middle = (n + k) // 2    # средний индекс в интервале индексов от n до k


# Основной блок программы бинарного поиска в массиве чисел
print('Используя бинарный поиск, определить есть ли заданный элемент в массиве')
sort = [1, 3, 7, 8, 15, 16, 19, 20, 30, 32]
num = float(input('Введите число'))
print('Поиск числа {} в массиве из задания'.format(num), sort)
binary_search(sort, num)

# проверка бинарного поиска для массива вещественных чисел
sort_float = []
for i in range(0, 70, 5):
    sort_float.append(i*0.5)
print('Поиск числа {} в массиве десятичных чисел'.format(num), sort_float)
binary_search(sort_float, num)




